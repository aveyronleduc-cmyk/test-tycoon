<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arena Duel – 2 joueurs (Local & WebRTC)</title>
<style>
  :root {
    --bg: #0b1020; --panel: #111831; --accent: #6cf; --accent2:#9f6cff; --ink:#e7ecff;
    --ok:#30d158; --warn:#ff9f0a; --bad:#ff453a;
  }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji; }
  #ui { position:fixed; inset:12px auto auto 12px; z-index:5; max-width: 520px; }
  .card { background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 40px rgba(0,0,0,0.35); border-radius:18px; padding:14px 16px; backdrop-filter: blur(8px); }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center }
  .col { display:flex; flex-direction:column; gap:10px }
  .title { font-size:20px; font-weight:800; letter-spacing:.2px; }
  .subtitle { font-size:13px; opacity:.8 }
  button, input, textarea, select { color:var(--ink); background:#0f1630; border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:10px 12px; font:inherit }
  button { cursor:pointer; transition: transform .06s ease, background .2s ease, border-color .2s ease; }
  button:hover { transform: translateY(-1px) }
  .primary { background: linear-gradient(135deg, #3565ff, #7b3dff); border-color: transparent; }
  .ghost { background: transparent }
  .good { background: linear-gradient(135deg, #2ac186, #3de0c0); border-color:transparent }
  .warn { background: linear-gradient(135deg, #ffb020, #ff7a00); border-color:transparent }
  .bad { background: linear-gradient(135deg, #ff5b5b, #ff3b3b); border-color:transparent }
  .muted { opacity:.7 }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  #help { font-size:12px; line-height:1.4 }
  #netPanel { display:none }
  #stateBadge { padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.18); font-size:12px }
  .badge-ok { background:rgba(48,209,88,0.15); color:#b0ffcb }
  .badge-warn { background:rgba(255,159,10,0.15); color:#ffe1b5 }
  .badge-bad { background:rgba(255,69,58,0.15); color:#ffc7c3 }
  #toast { position: fixed; right: 12px; bottom: 12px; z-index: 20; display:none }
  #toast .msg { background: #101735; border:1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 10px 12px }
  canvas { display:block; width:100vw; height:100vh; }
  #crosshair { position: fixed; pointer-events:none; inset:auto; color:#fff; opacity:.8; z-index:2 }
  #overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none }
  #bigMsg { pointer-events:none; font-size:48px; font-weight:900; background: linear-gradient(135deg, #6cf, #a6f); -webkit-background-clip: text; background-clip: text; color:transparent; text-shadow: 0 8px 50px rgba(124, 172, 255, 0.25); }
  .kbd { padding:3px 6px; border-radius:8px; border:1px solid rgba(255,255,255,0.2); background:rgba(255,255,255,0.06); font-weight:700 }
  details { border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:8px 12px }
  summary { cursor:pointer }
</style>
</head>
<body>
  <div id="ui" class="card col">
    <div class="row" style="justify-content:space-between; align-items:flex-start">
      <div>
        <div class="title">Arena Duel — multijoueur</div>
        <div class="subtitle">Joue en <b>local (2 onglets)</b> ou <b>en ligne (WebRTC)</b>. Code 100% client, un seul fichier.</div>
      </div>
      <div id="stateBadge" class="badge-warn">prêt</div>
    </div>

    <div class="row">
      <button id="btnSolo" class="good">Solo (vs bot)</button>
      <button id="btnLocal" class="primary">Local : 2 onglets</button>
      <button id="btnHost" class="ghost">Héberger (WebRTC)</button>
      <button id="btnJoin" class="ghost">Rejoindre (WebRTC)</button>
      <button id="btnReset" class="bad" title="Recharger la page">Réinitialiser</button>
    </div>

    <div id="netPanel" class="col">
      <div class="subtitle">Réseau</div>
      <div class="row">
        <label>Code salle&nbsp;<input id="room" class="mono" placeholder="auto" size="7"/></label>
        <button id="makeRoom">Générer</button>
      </div>

      <details id="localDetails">
        <summary>Local (BroadcastChannel)</summary>
        <div class="col" style="gap:6px">
          <div class="subtitle">Ouvre la <b>même page dans un second onglet</b>, et entre le <b>même code</b> dans les deux.</div>
          <div class="row"><button id="startLocal" class="primary">Démarrer Local</button><span class="muted">(2 joueurs max)</span></div>
        </div>
      </details>

      <details id="webrtcDetails">
        <summary>En ligne (WebRTC — échange manuel d'SDP)</summary>
        <div class="col" style="gap:8px">
          <div>
            <div class="subtitle">Étapes rapides :</div>
            <ol class="subtitle">
              <li><b>Hôte</b> : clique « Héberger », puis « Créer offre » et <b>copie</b> l'Offre.</li>
              <li><b>Invité</b> : clique « Rejoindre », <b>colle</b> l'Offre, crée la Réponse et renvoie-la à l'Hôte.</li>
              <li><b>Hôte</b> : colle la Réponse et tu es connecté.</li>
            </ol>
          </div>
          <div class="row">
            <button id="hostCreateOffer" class="primary">Créer offre (Hôte)</button>
            <button id="hostApplyAnswer" class="good">Coller réponse (Hôte)</button>
          </div>
          <textarea id="hostSDP" class="mono" rows="4" placeholder="Offre (à copier)"></textarea>
          <textarea id="hostAnswer" class="mono" rows="3" placeholder="Réponse (à coller)"></textarea>
          <div class="row">
            <button id="joinApplyOffer" class="primary">Coller offre (Invité)</button>
            <button id="joinCreateAnswer" class="good">Créer réponse (Invité)</button>
          </div>
          <textarea id="joinOffer" class="mono" rows="3" placeholder="Offre (à coller)"></textarea>
          <textarea id="joinSDP" class="mono" rows="4" placeholder="Réponse (à copier)"></textarea>
        </div>
      </details>
    </div>

    <div id="help" class="subtitle">
      <div><span class="kbd">ZQSD</span> pour bouger · <span class="kbd">Souris</span> pour viser · <span class="kbd">Clic</span> tirer · <span class="kbd">R</span> recharger · Premier à 5 éliminations gagne.</div>
    </div>
  </div>

  <canvas id="game"></canvas>
  <div id="overlay"><div id="bigMsg"></div></div>
  <svg id="crosshair" width="24" height="24" viewBox="0 0 24 24">
    <circle cx="12" cy="12" r="8" fill="none" stroke="white" stroke-width="1" opacity="0.6"/>
    <circle cx="12" cy="12" r="2" fill="white" opacity="0.9"/>
  </svg>
  <div id="toast"><div class="msg" id="toastMsg"></div></div>

<script>
(function(){
  const randId = () => Math.random().toString(36).slice(2, 10);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const dist2=(x1,y1,x2,y2)=>{let dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy};
  const now=()=>performance.now();

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));

  const ui = {
    stateBadge: document.getElementById('stateBadge'),
    netPanel: document.getElementById('netPanel'),
    room: document.getElementById('room'),
    makeRoom: document.getElementById('makeRoom'),
    btnSolo: document.getElementById('btnSolo'),
    btnLocal: document.getElementById('btnLocal'),
    btnHost: document.getElementById('btnHost'),
    btnJoin: document.getElementById('btnJoin'),
    btnReset: document.getElementById('btnReset'),
    localDetails: document.getElementById('localDetails'),
    webrtcDetails: document.getElementById('webrtcDetails'),
    hostCreateOffer: document.getElementById('hostCreateOffer'),
    hostApplyAnswer: document.getElementById('hostApplyAnswer'),
    joinApplyOffer: document.getElementById('joinApplyOffer'),
    joinCreateAnswer: document.getElementById('joinCreateAnswer'),
    hostSDP: document.getElementById('hostSDP'),
    hostAnswer: document.getElementById('hostAnswer'),
    joinOffer: document.getElementById('joinOffer'),
    joinSDP: document.getElementById('joinSDP'),
    bigMsg: document.getElementById('bigMsg'),
    toast: document.getElementById('toast'),
    toastMsg: document.getElementById('toastMsg'),
  };

  function setBadge(text, kind='warn'){
    ui.stateBadge.className='';
    ui.stateBadge.classList.add(kind==='ok'?'badge-ok':kind==='bad'?'badge-bad':'badge-warn');
    ui.stateBadge.textContent=text;
  }
  function toast(msg){
    ui.toastMsg.textContent=msg;
    ui.toast.style.display='block';
    setTimeout(()=> ui.toast.style.display='none', 2200);
  }

  function resize(){
    const w = window.innerWidth, h=window.innerHeight;
    canvas.width = Math.floor(w*dpr); canvas.height=Math.floor(h*dpr);
    canvas.style.width=w+'px'; canvas.style.height=h+'px';
  }
  window.addEventListener('resize', resize); resize();

  // ===== Input handling =====
  const input = { up:false, down:false, left:false, right:false, shoot:false, reload:false, mx:0, my:0, aim:0 };
  const KEYS = { KeyW:'up', KeyZ:'up', ArrowUp:'up', KeyS:'down', ArrowDown:'down', KeyA:'left', KeyQ:'left', ArrowLeft:'left', KeyD:'right', ArrowRight:'right' };
  document.addEventListener('keydown', (e)=>{
    if (e.repeat) return; if (e.code==='KeyR') input.reload=true;
    const k = KEYS[e.code]; if (k){ input[k]=true; }
  });
  document.addEventListener('keyup', (e)=>{
    const k = KEYS[e.code]; if (k){ input[k]=false; }
    if (e.code==='KeyR') input.reload=false;
  });
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    input.mx = (e.clientX-rect.left)*dpr; input.my=(e.clientY-rect.top)*dpr;
  });
  canvas.addEventListener('mousedown', ()=>{ input.shoot=true; });
  document.addEventListener('mouseup', ()=>{ input.shoot=false; });

  // ===== Game State =====
  const WORLD = { w: 2600, h: 1600 };
  const SPAWNS = [ [300,300], [WORLD.w-300, 300], [WORLD.w-300, WORLD.h-300], [300, WORLD.h-300], [WORLD.w/2, WORLD.h/2] ];

  const game = {
    me: null, // playerId string
    host: null, // playerId string
    mode: 'menu', // 'menu'|'playing'|'ended'
    killTarget: 5,
    players: {}, // id->player
    bullets: [],
    particles: [],
    lastTick: now(),
    camera: { x:0, y:0 },
    net: null,
    isHost(){ return this.me && this.me===this.host },
  };

  function newPlayer(id, color){
    return { id, x: WORLD.w/2 + (Math.random()*200-100), y: WORLD.h/2 + (Math.random()*200-100), vx:0, vy:0, r:18,
      color, hp:100, dead:false, respawnAt:0, score:0, ammo:6, maxAmmo:6, reloadTime:0, lastShot:0 };
  }

  // ===== Networking =====
  const Net = (function(){
    class NetBase{
      constructor(kind){ this.kind=kind; this.onMsg=()=>{}; this.ready=false; this.latency=0; this._latSamples=[]; }
      send(_){}
      close(){}
      setOnMsg(fn){ this.onMsg=fn; }
      sampleLatency(sentAt){ const rtt = now()-sentAt; this._latSamples.push(rtt); if (this._latSamples.length>20) this._latSamples.shift(); this.latency = Math.round(this._latSamples.reduce((a,b)=>a+b,0)/this._latSamples.length); }
    }

    class LocalBC extends NetBase{
      constructor(room){ super('local'); this.room=room||('room-'+randId()); this.bc = new BroadcastChannel('arena:'+this.room); this.ready=true; this.bc.onmessage = (ev)=> this.onMsg(ev.data); }
      send(msg){ try{ this.bc.postMessage(msg);}catch(e){} }
      close(){ try{ this.bc.close(); }catch(e){} }
    }

    class WebRTC extends NetBase{
      constructor(role){ super('webrtc'); this.role=role; this.pc=null; this.dc=null; this._onIceDone=null; }
      _setupDC(dc){ this.dc=dc; dc.onopen=()=>{ this.ready=true; setBadge('en ligne', 'ok'); toast('Connecté !'); };
        dc.onmessage=(ev)=>{ try{ const m=JSON.parse(ev.data); if(m._ping){ this.send({_pong:m._ping}); } else if (m._pong){ this.sampleLatency(m._pong); } else this.onMsg(m);}catch(e){} };
        dc.onclose=()=>{ setBadge('déconnecté', 'bad'); };
      }
      async hostCreateOffer(){
        this.pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
        this._setupDC(this.pc.createDataChannel('game'));
        this.pc.onicecandidate = (e)=>{ if(!e.candidate && this._onIceDone) this._onIceDone(JSON.stringify(this.pc.localDescription)); };
        await this.pc.setLocalDescription(await this.pc.createOffer());
        return new Promise(res=>{ this._onIceDone = res; });
      }
      async hostApplyAnswer(answerStr){ const desc = JSON.parse(answerStr); await this.pc.setRemoteDescription(desc); this._startPings(); }
      async joinApplyOffer(offerStr){ this.pc=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]}); this.pc.ondatachannel=(e)=>this._setupDC(e.channel);
        await this.pc.setRemoteDescription(JSON.parse(offerStr));
        this.pc.onicecandidate = (e)=>{ if(!e.candidate && this._onIceDone) this._onIceDone(JSON.stringify(this.pc.localDescription)); };
        await this.pc.setLocalDescription(await this.pc.createAnswer());
        return new Promise(res=>{ this._onIceDone = res; });
      }
      async joinCreateAnswer(){ const sdp = await new Promise(r=>{ const t=setInterval(()=>{ if(this.pc && this.pc.localDescription){ clearInterval(t); r(JSON.stringify(this.pc.localDescription)); } }, 50); }); return sdp; }
      send(msg){ if(this.dc && this.dc.readyState==='open'){ this.dc.send(JSON.stringify(msg)); } }
      _startPings(){ setInterval(()=>{ if(this.dc && this.dc.readyState==='open'){ this.send({_ping:now()}); } }, 1000); }
      close(){ try{ this.dc&&this.dc.close(); this.pc&&this.pc.close(); }catch(e){} }
    }

    return { LocalBC, WebRTC };
  })();

  // ===== Game Logic =====
  function spawnPlayer(p){ const s=SPAWNS[Math.floor(Math.random()*SPAWNS.length)]; p.x=s[0]; p.y=s[1]; p.vx=p.vy=0; p.hp=100; p.dead=false; p.respawnAt=0; p.ammo=p.maxAmmo; }

  function fireBullet(p){ if (now()-p.lastShot<140) return; if (p.ammo<=0) return; p.lastShot = now(); p.ammo--;
    const speed=920, life=900; const dir=p.aim||0; const spread= (Math.random()-0.5)*0.08; const a=dir+spread; const r=p.r+8;
    const b={ x:p.x+Math.cos(a)*r, y:p.y+Math.sin(a)*r, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, t:now(), life };
    game.bullets.push(b); addMuzzleFlash(p);
  }
  function addMuzzleFlash(p){ for(let i=0;i<10;i++){ const ang=(p.aim||0)+ (Math.random()-0.5)*0.6; const sp=120+Math.random()*120; game.particles.push({x:p.x, y:p.y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, r:2+Math.random()*3, life:250}); } }
  function addHit(x,y){ for(let i=0;i<16;i++){ const ang=Math.random()*Math.PI*2; const sp=100+Math.random()*220; game.particles.push({x, y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, r:2+Math.random()*3, life:380}); } }

  function update(dt){
    // host runs authoritative sim
    if (game.isHost()){
      // integrate player inputs
      Object.values(game.players).forEach(p=>{
        if (p.dead){ if (now()>p.respawnAt){ spawnPlayer(p); } return; }
        const s=p._in||{up:false,down:false,left:false,right:false,shoot:false,reload:false, aim:p.aim||0};
        const ACC=1800, FRIC=0.88, MAXS=330;
        let ax=0, ay=0; if(s.up) ay-=ACC; if(s.down) ay+=ACC; if(s.left) ax-=ACC; if(s.right) ax+=ACC;
        p.vx=(p.vx+ax*dt)*FRIC; p.vy=(p.vy+ay*dt)*FRIC; const sp=Math.hypot(p.vx,p.vy); if(sp>MAXS){ p.vx*=MAXS/sp; p.vy*=MAXS/sp; }
        p.x+=p.vx*dt; p.y+=p.vy*dt; p.x=clamp(p.x, 50, WORLD.w-50); p.y=clamp(p.y, 50, WORLD.h-50);
        p.aim = s.aim;
        if (s.reload){ p.reloadTime=500; p.ammo=p.maxAmmo; }
        if (s.shoot){ fireBullet(p); }
      });

      // bullets
      for (let i=game.bullets.length-1;i>=0;i--){ const b=game.bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; if(now()-b.t>b.life){ game.bullets.splice(i,1); continue; }
        // collide players
        for (const p of Object.values(game.players)){
          if (p.dead) continue; if (dist2(b.x,b.y,p.x,p.y) < (p.r+3)*(p.r+3)){
            addHit(b.x,b.y); p.hp-=34; game.bullets.splice(i,1);
            if (p.hp<=0){ p.dead=true; p.respawnAt=now()+1500; // award kill to others
              for (const q of Object.values(game.players)) if(q!==p) q.score++;
            }
            break;
          }
        }
      }

      // particles
      for (let i=game.particles.length-1;i>=0;i--){ const pa=game.particles[i]; pa.x+=pa.vx*dt; pa.y+=pa.vy*dt; pa.vx*=0.98; pa.vy*=0.98; pa.life-=dt*1000; if(pa.life<=0) game.particles.splice(i,1); }

      // broadcast state at ~30Hz
      if (game.net && game.net.ready && (!game._lastStateSend || now()-game._lastStateSend>33)){
        const state = { t:now(), players:Object.fromEntries(Object.entries(game.players).map(([id,p])=>[id, {x:p.x,y:p.y,vx:p.vx,vy:p.vy, hp:p.hp, dead:p.dead, respawnAt:p.respawnAt, score:p.score, ammo:p.ammo, aim:p.aim} ])), bullets: game.bullets.map(b=>({x:b.x,y:b.y,vx:b.vx,vy:b.vy,t:b.t,life:b.life})), particles: [] };
        game.net.send({type:'state', state}); game._lastStateSend=now();
      }
    }

    // camera follows local player
    const me = game.players[game.me];
    if (me){ game.camera.x = lerp(game.camera.x, me.x - canvas.width/2, 0.08); game.camera.y = lerp(game.camera.y, me.y - canvas.height/2, 0.08); }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.save(); ctx.translate(-game.camera.x, -game.camera.y);

    // background grid
    const grid=80; ctx.globalAlpha=0.6; ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.beginPath();
    for(let x=0;x<=WORLD.w;x+=grid){ ctx.moveTo(x,0); ctx.lineTo(x,WORLD.h); }
    for(let y=0;y<=WORLD.h;y+=grid){ ctx.moveTo(0,y); ctx.lineTo(WORLD.w,y); }
    ctx.stroke(); ctx.globalAlpha=1;

    // arena border
    ctx.strokeStyle='rgba(140,170,255,0.6)'; ctx.lineWidth=3; ctx.strokeRect(20,20,WORLD.w-40,WORLD.h-40);

    // particles
    for (const p of game.particles){ ctx.fillStyle='rgba(255,200,140,0.9)'; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); }

    // bullets
    ctx.fillStyle='rgba(255,255,255,0.9)';
    for (const b of game.bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill(); }

    // players
    for (const p of Object.values(game.players)){
      ctx.save();
      ctx.translate(p.x,p.y);
      // shadow
      ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(0,12,16,8,0,0,Math.PI*2); ctx.fill();
      // body
      const col = p.color || '#6cf';
      ctx.fillStyle=col; ctx.beginPath(); ctx.arc(0,0,p.r,0,Math.PI*2); ctx.fill();
      // gun
      ctx.rotate(p.aim||0); ctx.fillStyle='#fff'; ctx.fillRect(8,-3,18,6);
      ctx.restore();

      // hp bar
      ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.fillRect(p.x-18,p.y-30,36,6);
      ctx.fillStyle='rgba(64,220,120,0.9)'; ctx.fillRect(p.x-18,p.y-30,36*clamp(p.hp/100,0,1),6);

      // name+score
      ctx.font='12px system-ui, sans-serif'; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText((p.id===game.me?'Moi':'Adversaire')+` — ${p.score}`, p.x-22, p.y-40);

      if (p.dead){ ctx.font='bold 18px system-ui'; ctx.fillStyle='rgba(255,90,90,0.9)'; ctx.fillText('K.O', p.x-12, p.y-4); }
    }

    ctx.restore();

    // HUD ammo
    const me = game.players[game.me];
    if (me){
      ctx.font='bold 18px system-ui'; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText(`Kills ${me.score}/${game.killTarget} · Munitions ${me.ammo}/${me.maxAmmo}` , 16, 28);
    }
  }

  // ===== Networking glue =====
  function wireNetwork(){
    if (!game.net) return;
    game.net.setOnMsg((msg)=>{
      if (msg.type==='hello'){ // discovery for local
        if (!game.host) game.host = msg.host; // first hello decides host if not set
        // respond with my id so we see each other
        if (game.net.kind==='local') game.net.send({type:'ack', from:game.me});
      } else if (msg.type==='ack'){
        // no-op; presence established
      } else if (msg.type==='input'){ const p = game.players[msg.id]; if (p){ p._in = msg.input; } }
      else if (msg.type==='state' && !game.isHost()){
        const s=msg.state; // apply snapshot
        for (const [id, ps] of Object.entries(s.players)){
          if (!game.players[id]) game.players[id]=newPlayer(id, id===game.me? '#6cf':'#ff9f6c');
          Object.assign(game.players[id], ps);
        }
        game.bullets = s.bullets;
      }
    });
  }

  function startLocal(){
    const room = (ui.room.value||'').trim() || randId().slice(0,6);
    ui.room.value = room; game.net = new Net.LocalBC(room); wireNetwork(); setBadge('local '+room, 'ok');
    if (!game.me) game.me = 'p-'+randId(); if (!game.host) game.host = game.me; // first caller is host
    setupPlayers();
    // announce presence
    game.net.send({type:'hello', host:game.host});
    game.mode='playing';
  }

  function startHost(){ game.net = new Net.WebRTC('host'); wireNetwork(); setBadge('création de l\'offre…'); ui.netPanel.style.display='block'; ui.webrtcDetails.open=true; }
  function startJoin(){ game.net = new Net.WebRTC('join'); wireNetwork(); setBadge('en attente d\'offre'); ui.netPanel.style.display='block'; ui.webrtcDetails.open=true; }

  function setupPlayers(){
    // two players only (me + opponent placeholder)
    const meId = game.me || ('p-'+randId()); game.me=meId;
    if (!game.players[meId]) game.players[meId]=newPlayer(meId, '#6cf'); spawnPlayer(game.players[meId]);
    const otherId = (Object.keys(game.players).find(id=>id!==meId)) || 'p-rival';
    if (!game.players[otherId]) game.players[otherId]=newPlayer(otherId, '#ff9f6c'); spawnPlayer(game.players[otherId]);
  }

  function startSolo(){
    game.net = null; setBadge('solo', 'ok'); ui.netPanel.style.display='none';
    game.me = 'p-me'; game.host = game.me; game.players={};
    const me = newPlayer(game.me, '#6cf'); spawnPlayer(me); game.players[game.me]=me;
    const botId = 'p-bot'; const bot = newPlayer(botId, '#ff9f6c'); spawnPlayer(bot); game.players[botId]=bot; bot.isBot=true;
    game.mode='playing';
  }

  function updateBot(p, dt){ const me = game.players[game.me]; if (!me) return; // simple chase & strafe
    const dx=me.x-p.x, dy=me.y-p.y, d=Math.hypot(dx,dy)+1e-6; const aim=Math.atan2(dy,dx); p._in={ up:dy<0, down:dy>0, left:dx<0, right:dx>0, shoot:(d<600), reload:false, aim };
    if (Math.random()<0.003) p._in.reload=true; else p._in.reload=false;
  }

  // ===== Main Loop =====
  function frame(){
    const t = now(); let dt = (t-game.lastTick)/1000; game.lastTick = t; dt = Math.min(dt, 0.033);

    // collect & send input to host
    const me = game.players[game.me];
    if (me){
      me.aim = Math.atan2(input.my - me.y + game.camera.y, input.mx - me.x + game.camera.x);
      const pack = { up:input.up, down:input.down, left:input.left, right:input.right, shoot:input.shoot, reload:input.reload, aim:me.aim };
      if (game.isHost()) me._in = pack; else if (game.net && game.net.ready) game.net.send({type:'input', id:game.me, input:pack});
    }

    // bot AI
    for (const p of Object.values(game.players)) if (p.isBot) updateBot(p, dt);

    update(dt);
    draw();

    // win/lose
    const winner = Object.values(game.players).find(p=>p.score>=game.killTarget);
    if (winner && game.mode==='playing'){ game.mode='ended'; ui.bigMsg.textContent=(winner.id===game.me?'Tu gagnes !':'Défaite…'); setTimeout(()=>{ ui.bigMsg.textContent=''; game.mode='playing'; Object.values(game.players).forEach(p=>p.score=0); }, 2400); }

    requestAnimationFrame(frame);
  }

  // ===== UI wiring =====
  ui.btnReset.onclick = ()=> location.reload();
  ui.btnSolo.onclick = ()=> startSolo();
  ui.btnLocal.onclick = ()=>{ ui.netPanel.style.display='block'; ui.localDetails.open=true; setBadge('local prêt'); };
  ui.makeRoom.onclick = ()=>{ ui.room.value = randId().slice(0,6); };
  document.getElementById('startLocal').onclick = ()=> startLocal();

  ui.btnHost.onclick = ()=> startHost();
  ui.btnJoin.onclick = ()=> startJoin();

  ui.hostCreateOffer.onclick = async()=>{ try{ const sdp = await game.net.hostCreateOffer(); ui.hostSDP.value = sdp; setBadge('offre prête', 'ok'); toast('Offre créée — copie et envoie-la à ton invité.'); game.me = 'host-'+randId(); game.host = game.me; setupPlayers(); } catch(e){ setBadge('erreur', 'bad'); console.error(e);} };
  ui.hostApplyAnswer.onclick = async()=>{ try{ await game.net.hostApplyAnswer(ui.hostAnswer.value.trim()); toast('Réponse appliquée.'); } catch(e){ toast('Réponse invalide'); } };
  ui.joinApplyOffer.onclick = async()=>{ try{ const sdp = await game.net.joinApplyOffer(ui.joinOffer.value.trim()); ui.joinSDP.value = sdp; toast('Réponse générée — renvoie-la à l\'hôte.'); game.me = 'guest-'+randId(); game.host = 'host-remote'; setupPlayers(); setBadge('en attente de connexion…'); } catch(e){ toast('Offre invalide'); } };
  ui.joinCreateAnswer.onclick = async()=>{ try{ const ans = await game.net.joinCreateAnswer(); ui.joinSDP.value = ans; setBadge('réponse prête', 'ok'); } catch(e){ toast('Impossible de créer la réponse'); } };

  // Kickoff
  setBadge('prêt'); frame();
})();
</script>
</body>
</html>
